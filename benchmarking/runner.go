// Copyright 2026 Siddharth Viswanathan
// This file was fully generated by Codex and may contain modifications by Siddharth Viswanathan as of 2026.
// SPDX-License-Identifier: Apache-2.0

package main

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"io"
	"math"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"sort"
	"strings"
	"time"
)

type stats struct {
	Count    int     `json:"count"`
	MeanMS   float64 `json:"mean_ms"`
	MedianMS float64 `json:"median_ms"`
	P95MS    float64 `json:"p95_ms"`
	StdDevMS float64 `json:"stddev_ms"`
	MinMS    float64 `json:"min_ms"`
	MaxMS    float64 `json:"max_ms"`
}

type scenarioResult struct {
	Name          string  `json:"name"`
	Description   string  `json:"description"`
	Git           stats   `json:"git"`
	VCS           stats   `json:"vcs"`
	OverheadRatio float64 `json:"overhead_ratio"`
	OverheadPct   float64 `json:"overhead_pct"`
}

type report struct {
	TimestampUTC     string           `json:"timestamp_utc"`
	HostOS           string           `json:"host_os"`
	HostArch         string           `json:"host_arch"`
	GitBinary        string           `json:"git_binary"`
	VCSBinary        string           `json:"vcs_binary"`
	Iterations       int              `json:"iterations"`
	WarmupIterations int              `json:"warmup_iterations"`
	ScenarioCount    int              `json:"scenario_count"`
	Results          []scenarioResult `json:"results"`
}

type scenario struct {
	Name        string
	Description string
	GitArgs     func(iteration int) []string
	VCSArgs     func(iteration int) []string
	Prepare     func(repoPath string, iteration int, gitBin string) error
	Cleanup     func(repoPath string, iteration int, gitBin string) error
}

func main() {
	var (
		gitBin      = flag.String("git-bin", "git", "path to git binary (or executable name on PATH)")
		vcsBin      = flag.String("vcs-bin", "", "path to vcs binary (or executable name on PATH)")
		iterations  = flag.Int("iterations", 40, "number of measured iterations per scenario")
		warmup      = flag.Int("warmup", 8, "number of warmup iterations per scenario")
		timeout     = flag.Duration("timeout", 15*time.Second, "per-command timeout")
		jsonOutPath = flag.String("json-out", "", "optional output path for JSON report")
		mdOutPath   = flag.String("md-out", "", "optional output path for Markdown report")
		keepTemp    = flag.Bool("keep-temp", false, "keep temporary benchmark workspace")
	)
	flag.Parse()

	if *iterations < 1 {
		exitf("iterations must be >= 1")
	}
	if *warmup < 0 {
		exitf("warmup must be >= 0")
	}

	resolvedGit, err := resolveBinary(*gitBin, nil)
	if err != nil {
		exitf("failed to resolve git binary: %v", err)
	}

	vcsCandidates := []string{}
	if *vcsBin != "" {
		vcsCandidates = append(vcsCandidates, *vcsBin)
	}
	vcsCandidates = append(vcsCandidates, "./vcs", "../vcs", "vcs")
	resolvedVCS, err := resolveBinary("", vcsCandidates)
	if err != nil {
		exitf("failed to resolve vcs binary: %v", err)
	}

	workspace, err := os.MkdirTemp("", "vcs-benchmark-*")
	if err != nil {
		exitf("failed to create temp workspace: %v", err)
	}
	if !*keepTemp {
		defer os.RemoveAll(workspace)
	}

	templateRepo := filepath.Join(workspace, "template-repo")
	if err := createTemplateRepo(templateRepo, resolvedGit); err != nil {
		exitf("failed to create template repository: %v", err)
	}

	scenarios := defineScenarios()
	results := make([]scenarioResult, 0, len(scenarios))

	for _, sc := range scenarios {
		gitRepo := filepath.Join(workspace, "repos", sc.Name, "git")
		vcsRepo := filepath.Join(workspace, "repos", sc.Name, "vcs")

		if err := copyDir(templateRepo, gitRepo); err != nil {
			exitf("failed to prepare git repo for %s: %v", sc.Name, err)
		}
		if err := copyDir(templateRepo, vcsRepo); err != nil {
			exitf("failed to prepare vcs repo for %s: %v", sc.Name, err)
		}

		gitDurations, err := runScenario(sc, gitRepo, resolvedGit, sc.GitArgs, resolvedGit, *iterations, *warmup, *timeout)
		if err != nil {
			exitf("scenario %s failed for git: %v", sc.Name, err)
		}

		vcsDurations, err := runScenario(sc, vcsRepo, resolvedVCS, sc.VCSArgs, resolvedGit, *iterations, *warmup, *timeout)
		if err != nil {
			exitf("scenario %s failed for vcs: %v", sc.Name, err)
		}

		gitStats := calcStats(gitDurations)
		vcsStats := calcStats(vcsDurations)

		ratio := math.NaN()
		overheadPct := math.NaN()
		if gitStats.MeanMS > 0 {
			ratio = vcsStats.MeanMS / gitStats.MeanMS
			overheadPct = (ratio - 1.0) * 100.0
		}

		results = append(results, scenarioResult{
			Name:          sc.Name,
			Description:   sc.Description,
			Git:           gitStats,
			VCS:           vcsStats,
			OverheadRatio: ratio,
			OverheadPct:   overheadPct,
		})
	}

	rep := report{
		TimestampUTC:     time.Now().UTC().Format(time.RFC3339),
		HostOS:           runtime.GOOS,
		HostArch:         runtime.GOARCH,
		GitBinary:        resolvedGit,
		VCSBinary:        resolvedVCS,
		Iterations:       *iterations,
		WarmupIterations: *warmup,
		ScenarioCount:    len(results),
		Results:          results,
	}

	printSummary(rep)

	if *jsonOutPath != "" {
		if err := writeJSON(*jsonOutPath, rep); err != nil {
			exitf("failed to write JSON report: %v", err)
		}
	}
	if *mdOutPath != "" {
		if err := writeMarkdown(*mdOutPath, rep); err != nil {
			exitf("failed to write Markdown report: %v", err)
		}
	}

	if *keepTemp {
		fmt.Printf("\nkept benchmark workspace: %s\n", workspace)
	}
}

func defineScenarios() []scenario {
	return []scenario{
		{
			Name:        "status_short_clean",
			Description: "Working tree status in a clean repository",
			GitArgs: func(_ int) []string {
				return []string{"status", "--short"}
			},
			VCSArgs: func(_ int) []string {
				return []string{"status", "--short"}
			},
		},
		{
			Name:        "log_head_oneline",
			Description: "Show latest commit as one line",
			GitArgs: func(_ int) []string {
				return []string{"log", "-n", "1", "--oneline"}
			},
			VCSArgs: func(_ int) []string {
				return []string{"log", "-n", "1", "--oneline"}
			},
		},
		{
			Name:        "branch_list",
			Description: "List local branches",
			GitArgs: func(_ int) []string {
				return []string{"branch", "--list"}
			},
			VCSArgs: func(_ int) []string {
				return []string{"branch", "--list"}
			},
		},
		{
			Name:        "checkout_branch",
			Description: "Checkout an existing local branch",
			GitArgs: func(_ int) []string {
				return []string{"checkout", "bench-other"}
			},
			VCSArgs: func(_ int) []string {
				return []string{"checkout", "bench-other"}
			},
			Cleanup: func(repoPath string, _ int, gitBin string) error {
				return runCommand(repoPath, gitBin, []string{"checkout", "main"}, 20*time.Second)
			},
		},
		{
			Name:        "stage_single_file",
			Description: "Stage one modified file",
			GitArgs: func(_ int) []string {
				return []string{"add", "--", "bench_target.txt"}
			},
			VCSArgs: func(_ int) []string {
				return []string{"stage", "bench_target.txt"}
			},
			Prepare: func(repoPath string, iteration int, _ string) error {
				return appendLine(filepath.Join(repoPath, "bench_target.txt"), fmt.Sprintf("stage-iteration-%d", iteration))
			},
			Cleanup: func(repoPath string, _ int, gitBin string) error {
				return runCommand(repoPath, gitBin, []string{"reset", "--hard", "HEAD"}, 20*time.Second)
			},
		},
		{
			Name:        "unstage_single_file",
			Description: "Unstage one file after it has been staged",
			GitArgs: func(_ int) []string {
				return []string{"restore", "--staged", "--", "bench_target.txt"}
			},
			VCSArgs: func(_ int) []string {
				return []string{"unstage", "bench_target.txt"}
			},
			Prepare: func(repoPath string, iteration int, gitBin string) error {
				if err := appendLine(filepath.Join(repoPath, "bench_target.txt"), fmt.Sprintf("unstage-iteration-%d", iteration)); err != nil {
					return err
				}
				return runCommand(repoPath, gitBin, []string{"add", "--", "bench_target.txt"}, 20*time.Second)
			},
			Cleanup: func(repoPath string, _ int, gitBin string) error {
				return runCommand(repoPath, gitBin, []string{"reset", "--hard", "HEAD"}, 20*time.Second)
			},
		},
		{
			Name:        "commit_allow_empty",
			Description: "Create an empty commit with a message",
			GitArgs: func(iteration int) []string {
				return []string{"commit", "--allow-empty", "-m", fmt.Sprintf("git-empty-bench-%d", iteration)}
			},
			VCSArgs: func(iteration int) []string {
				return []string{"commit", "--allow-empty", "-m", fmt.Sprintf("vcs-empty-bench-%d", iteration)}
			},
		},
	}
}

func runScenario(
	sc scenario,
	repoPath string,
	commandPath string,
	argsFn func(iteration int) []string,
	gitBin string,
	iterations int,
	warmup int,
	timeout time.Duration,
) ([]time.Duration, error) {
	totalRuns := warmup + iterations
	durations := make([]time.Duration, 0, iterations)

	for i := 0; i < totalRuns; i++ {
		if sc.Prepare != nil {
			if err := sc.Prepare(repoPath, i, gitBin); err != nil {
				return nil, fmt.Errorf("prepare failed at iteration %d: %w", i, err)
			}
		}

		args := argsFn(i)
		dur, stderr, err := runCommandTimed(repoPath, commandPath, args, timeout)
		if err != nil {
			return nil, fmt.Errorf("command failed at iteration %d: %s %v (stderr: %s)", i, commandPath, err, stderr)
		}

		if sc.Cleanup != nil {
			if err := sc.Cleanup(repoPath, i, gitBin); err != nil {
				return nil, fmt.Errorf("cleanup failed at iteration %d: %w", i, err)
			}
		}

		if i >= warmup {
			durations = append(durations, dur)
		}
	}

	return durations, nil
}

func createTemplateRepo(path string, gitBin string) error {
	if err := os.MkdirAll(path, 0o755); err != nil {
		return err
	}

	if err := runCommand(path, gitBin, []string{"init", "-b", "main"}, 20*time.Second); err != nil {
		return err
	}
	if err := runCommand(path, gitBin, []string{"config", "user.name", "Benchmark User"}, 20*time.Second); err != nil {
		return err
	}
	if err := runCommand(path, gitBin, []string{"config", "user.email", "benchmark@example.com"}, 20*time.Second); err != nil {
		return err
	}

	gitIgnore := []byte(".vcs/\nbenchmarking/\n")
	if err := os.WriteFile(filepath.Join(path, ".gitignore"), gitIgnore, 0o644); err != nil {
		return err
	}

	if err := os.WriteFile(filepath.Join(path, "bench_target.txt"), []byte("initial benchmark content\n"), 0o644); err != nil {
		return err
	}

	for i := 0; i < 200; i++ {
		name := fmt.Sprintf("file_%03d.txt", i)
		content := bytes.Repeat([]byte(fmt.Sprintf("line %03d benchmark payload\n", i)), 80)
		if err := os.WriteFile(filepath.Join(path, name), content, 0o644); err != nil {
			return err
		}
	}

	if err := runCommand(path, gitBin, []string{"add", "."}, 20*time.Second); err != nil {
		return err
	}
	if err := runCommand(path, gitBin, []string{"commit", "-m", "initial benchmark dataset"}, 20*time.Second); err != nil {
		return err
	}

	for i := 0; i < 30; i++ {
		if err := appendLine(filepath.Join(path, "file_000.txt"), fmt.Sprintf("history-step-%03d", i)); err != nil {
			return err
		}
		if err := runCommand(path, gitBin, []string{"add", "file_000.txt"}, 20*time.Second); err != nil {
			return err
		}
		if err := runCommand(path, gitBin, []string{"commit", "-m", fmt.Sprintf("history commit %03d", i)}, 20*time.Second); err != nil {
			return err
		}
	}

	if err := runCommand(path, gitBin, []string{"checkout", "-b", "bench-other"}, 20*time.Second); err != nil {
		return err
	}
	if err := appendLine(filepath.Join(path, "file_001.txt"), "bench-other branch update"); err != nil {
		return err
	}
	if err := runCommand(path, gitBin, []string{"add", "file_001.txt"}, 20*time.Second); err != nil {
		return err
	}
	if err := runCommand(path, gitBin, []string{"commit", "-m", "bench-other update"}, 20*time.Second); err != nil {
		return err
	}
	if err := runCommand(path, gitBin, []string{"checkout", "main"}, 20*time.Second); err != nil {
		return err
	}
	return nil
}

func runCommand(repoPath string, commandPath string, args []string, timeout time.Duration) error {
	_, _, err := runCommandTimed(repoPath, commandPath, args, timeout)
	return err
}

func runCommandTimed(repoPath string, commandPath string, args []string, timeout time.Duration) (time.Duration, string, error) {
	ctx, cancel := context.WithTimeout(context.Background(), timeout)
	defer cancel()

	cmd := exec.CommandContext(ctx, commandPath, args...)
	cmd.Dir = repoPath
	cmd.Env = append(os.Environ(), "GIT_PAGER=cat", "PAGER=cat", "LC_ALL=C")
	cmd.Stdout = io.Discard
	var stderr bytes.Buffer
	cmd.Stderr = &stderr

	start := time.Now()
	err := cmd.Run()
	dur := time.Since(start)
	errText := strings.TrimSpace(stderr.String())

	if errors.Is(ctx.Err(), context.DeadlineExceeded) {
		return dur, errText, fmt.Errorf("timed out after %s", timeout)
	}
	if err != nil {
		return dur, errText, err
	}
	return dur, errText, nil
}

func appendLine(path string, line string) error {
	f, err := os.OpenFile(path, os.O_APPEND|os.O_WRONLY, 0o644)
	if err != nil {
		return err
	}
	defer f.Close()

	if _, err := f.WriteString(line + "\n"); err != nil {
		return err
	}
	return nil
}

func calcStats(durations []time.Duration) stats {
	values := make([]float64, 0, len(durations))
	for _, d := range durations {
		values = append(values, float64(d)/float64(time.Millisecond))
	}
	sort.Float64s(values)

	if len(values) == 0 {
		return stats{}
	}

	var sum float64
	for _, v := range values {
		sum += v
	}
	mean := sum / float64(len(values))

	median := values[len(values)/2]
	if len(values)%2 == 0 {
		median = (values[len(values)/2-1] + values[len(values)/2]) / 2
	}

	p95Index := int(math.Ceil(0.95*float64(len(values)))) - 1
	if p95Index < 0 {
		p95Index = 0
	}
	if p95Index >= len(values) {
		p95Index = len(values) - 1
	}
	p95 := values[p95Index]

	var variance float64
	for _, v := range values {
		delta := v - mean
		variance += delta * delta
	}
	variance /= float64(len(values))

	return stats{
		Count:    len(values),
		MeanMS:   mean,
		MedianMS: median,
		P95MS:    p95,
		StdDevMS: math.Sqrt(variance),
		MinMS:    values[0],
		MaxMS:    values[len(values)-1],
	}
}

func resolveBinary(primary string, fallbacks []string) (string, error) {
	candidates := []string{}
	if strings.TrimSpace(primary) != "" {
		candidates = append(candidates, primary)
	}
	candidates = append(candidates, fallbacks...)

	var errs []string
	for _, candidate := range candidates {
		resolved, err := resolveBinaryOne(candidate)
		if err == nil {
			return resolved, nil
		}
		errs = append(errs, fmt.Sprintf("%q: %v", candidate, err))
	}

	return "", fmt.Errorf("none of the candidates resolved: %s", strings.Join(errs, "; "))
}

func resolveBinaryOne(pathOrName string) (string, error) {
	if strings.Contains(pathOrName, string(filepath.Separator)) {
		abs, err := filepath.Abs(pathOrName)
		if err != nil {
			return "", err
		}
		info, err := os.Stat(abs)
		if err != nil {
			return "", err
		}
		if info.IsDir() {
			return "", fmt.Errorf("is a directory")
		}
		return abs, nil
	}
	found, err := exec.LookPath(pathOrName)
	if err != nil {
		return "", err
	}
	return found, nil
}

func copyDir(src string, dst string) error {
	return filepath.Walk(src, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		rel, err := filepath.Rel(src, path)
		if err != nil {
			return err
		}
		target := filepath.Join(dst, rel)

		if info.IsDir() {
			return os.MkdirAll(target, info.Mode())
		}

		return copyFile(path, target, info.Mode())
	})
}

func copyFile(src string, dst string, mode os.FileMode) error {
	in, err := os.Open(src)
	if err != nil {
		return err
	}
	defer in.Close()

	out, err := os.OpenFile(dst, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, mode)
	if err != nil {
		return err
	}
	defer out.Close()

	if _, err := io.Copy(out, in); err != nil {
		return err
	}
	return nil
}

func printSummary(rep report) {
	fmt.Printf("Benchmark: git vs vcs wrapper overhead\n")
	fmt.Printf("Host: %s/%s\n", rep.HostOS, rep.HostArch)
	fmt.Printf("git: %s\n", rep.GitBinary)
	fmt.Printf("vcs: %s\n", rep.VCSBinary)
	fmt.Printf("iterations=%d warmup=%d\n\n", rep.Iterations, rep.WarmupIterations)

	fmt.Printf("%-24s %11s %11s %11s\n", "Scenario", "git mean", "vcs mean", "overhead")
	fmt.Printf("%s\n", strings.Repeat("-", 63))
	for _, r := range rep.Results {
		fmt.Printf(
			"%-24s %8.3f ms %8.3f ms %8.2f%%\n",
			r.Name,
			r.Git.MeanMS,
			r.VCS.MeanMS,
			r.OverheadPct,
		)
	}
}

func writeJSON(path string, rep report) error {
	if err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil {
		return err
	}
	data, err := json.MarshalIndent(rep, "", "  ")
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0o644)
}

func writeMarkdown(path string, rep report) error {
	if err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil {
		return err
	}

	var b strings.Builder
	b.WriteString("# Benchmark Report: git vs vcs\n\n")
	b.WriteString(fmt.Sprintf("- Timestamp (UTC): `%s`\n", rep.TimestampUTC))
	b.WriteString(fmt.Sprintf("- Host: `%s/%s`\n", rep.HostOS, rep.HostArch))
	b.WriteString(fmt.Sprintf("- git binary: `%s`\n", rep.GitBinary))
	b.WriteString(fmt.Sprintf("- vcs binary: `%s`\n", rep.VCSBinary))
	b.WriteString(fmt.Sprintf("- Iterations: `%d` (warmup `%d`)\n\n", rep.Iterations, rep.WarmupIterations))

	b.WriteString("| Scenario | git mean (ms) | vcs mean (ms) | Overhead (%) | git p95 (ms) | vcs p95 (ms) |\n")
	b.WriteString("|---|---:|---:|---:|---:|---:|\n")
	for _, r := range rep.Results {
		b.WriteString(fmt.Sprintf(
			"| `%s` | %.3f | %.3f | %.2f | %.3f | %.3f |\n",
			r.Name,
			r.Git.MeanMS,
			r.VCS.MeanMS,
			r.OverheadPct,
			r.Git.P95MS,
			r.VCS.P95MS,
		))
	}
	b.WriteString("\n")
	b.WriteString("## Notes\n\n")
	b.WriteString("- `vcs` is measured as the wrapper command path, not raw `git`.\n")
	b.WriteString("- Separate repositories are used for `git` and `vcs` in each scenario to avoid cross-interference.\n")
	b.WriteString("- `status`, `log`, `branch`, `checkout`, `stage`, `unstage`, and `commit --allow-empty` are covered.\n")

	return os.WriteFile(path, []byte(b.String()), 0o644)
}

func exitf(format string, args ...any) {
	fmt.Fprintf(os.Stderr, "error: "+format+"\n", args...)
	os.Exit(1)
}
